<!doctype html>

<html lang="en">  
<head>  
<meta charset="utf-8" />  
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />  
<title>Flappy Fury â€” TMI Studios (Xmas Tree: first + rare)</title>  
<style>  
/* Upgraded CSS (same as before) */  
:root{  
  --bg:#87CEEB;  
  --ground:#DEB887;  
  --pipe:#2E8B57;  
  --accent:#FFD700;  
  --outline:#000000;  
  --shine:rgba(255,255,255,0.45);  
  --shadow:rgba(0,0,0,0.25);  
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;  
}  
html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;}  
.frame{width:100%;max-width:480px;height:85vh;border-radius:14px;overflow:hidden;background:linear-gradient(var(--bg), #cde9ff 80%);position:relative;box-shadow:0 12px 28px rgba(0,0,0,.22);}  
canvas{display:block;width:100%;height:100%;}  
.ui{position:absolute;left:50%;transform:translateX(-50%);top:12px;text-align:center;color:white;text-shadow:0 2px 8px rgba(0,0,0,.4);pointer-events:none;width:90%;font-weight:700;z-index:10}  
.score{font-size:28px;letter-spacing:1px;}  
.sub{font-size:12px;opacity:.95;font-weight:700}  
.chaos{position:absolute;top:14%;left:50%;transform:translateX(-50%);color:#fff;font-size:22px;font-weight:800;text-shadow:0 3px 12px rgba(0,0,0,.7);text-align:center;width:92%;pointer-events:none;z-index:11;opacity:0;transition:opacity .3s ease}  
.overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:auto;z-index:12}  
.card{width:86%;max-width:390px;background:rgba(255,255,255,0.96);padding:20px;border-radius:14px;box-shadow:0 12px 28px rgba(0,0,0,.18);text-align:center;pointer-events:auto}  
.btn{display:inline-block;background:#111;color:#fff;padding:9px 14px;border-radius:10px;margin:6px;text-decoration:none;font-weight:700;cursor:pointer;box-shadow:0 3px 10px rgba(0,0,0,.18);transition:transform .12s}  
.btn:active{transform:scale(.96)}  
.small{font-size:13px;color:#444;margin-top:6px}  
.theme-row{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin:12px 0}  
.theme-tile{width:68px;height:68px;border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;font-weight:700;border:3px solid var(--outline);box-shadow:0 3px 8px rgba(0,0,0,.25), inset 0 0 12px rgba(255,255,255,.12);position:relative}  
.theme-tile::after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:12px;background:linear-gradient(145deg, transparent, var(--shine));opacity:.35;pointer-events:none}  
.theme-tile.locked{filter:grayscale(70%) brightness(.75);cursor:not-allowed}  
.theme-label{font-size:12px;margin-top:6px;text-shadow:0 1px 2px rgba(0,0,0,.25)}  
.limited-badge{position:absolute;top:10px;right:16px;background:#d9534f;color:white;padding:4px 8px;border-radius:8px;font-weight:700;font-size:12px;box-shadow:0 2px 7px rgba(0,0,0,.25)}  
footer{position:absolute;bottom:10px;width:100%;text-align:center;font-size:11px;color:white;opacity:.9;pointer-events:none;text-shadow:0 1px 6px rgba(0,0,0,.4)}  
.shop-overlay{position:absolute;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:20}  
.shop-card{width:90%;max-width:420px;background:#fff;padding:18px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.25);text-align:center}  
@media (min-width:700px){.frame{height:560px}}  
</style>  
</head>  
<body>  
<div class="frame" id="frame">  
  <div class="ui">  
    <div class="score" id="score">0</div>  
    <div class="sub">Tap or press <strong>Space</strong> to flap</div>  
  </div>    <div id="chaos" class="chaos" aria-hidden="true"></div>  <canvas id="game"></canvas>

  <!-- Start overlay -->    <div id="overlay" class="overlay">  
    <div class="card" id="card">  
      <h2 style="margin:0 0 8px">Flappy Fury â€” TMI Studios</h2>  
      <p id="message" style="margin:6px 0 12px;color:#555">Choose an avatar then Start.</p>  
      <div style="position:relative">  
        <div class="theme-row" id="themeRow"></div>  
        <div id="limitedBadge" class="limited-badge" style="display:none">LIMITED</div>  
      </div>  
      <div style="margin-top:10px">  
        <button id="startBtn" class="btn">Start Game</button>  
        <button id="shopBtn" class="btn" style="background:#007bff">Shop</button>  
        <button id="muteBtn" class="btn" style="background:#f0f0f0;color:#111">Mute</button>  
      </div>  
      <div class="small">High Score: <span id="high">0</span></div>  
    </div>  
  </div>    <!-- Shop overlay -->    <div id="shopOverlay" class="shop-overlay" style="display:none">  
    <div class="shop-card">  
      <h2>Shop â€” Avatars & Themes</h2>  
      <div class="theme-row" id="shopThemeRow"></div>  
      <div style="margin-top:12px">  
        <button id="shopBackBtn" class="btn">Back</button>  
      </div>  
    </div>  
  </div>    <footer>TMI Studios â€” Offline-ready demo</footer>  
</div>  <script>  
/* Full file with tree spawn changes:  
   - first pipe after starting is a tree (C)  
   - then tree spawns rarely (about every 6 pipes) (A)  
   - rest & landing behavior retained  
   - tree drawing is simple/cartoon (no external assets)  
*/  
  
(() => {  
  // elements  
  const frame = document.getElementById('frame');  
  const canvas = document.getElementById('game');  
  const ctx = canvas.getContext('2d');  
  const overlay = document.getElementById('overlay');  
  const startBtn = document.getElementById('startBtn');  
  const shopBtn = document.getElementById('shopBtn');  
  const shopOverlay = document.getElementById('shopOverlay');  
  const shopBackBtn = document.getElementById('shopBackBtn');  
  const muteBtn = document.getElementById('muteBtn');  
  const scoreEl = document.getElementById('score');  
  const highEl = document.getElementById('high');  
  const chaosEl = document.getElementById('chaos');  
  const messageEl = document.getElementById('message');  
  const themeRow = document.getElementById('themeRow');  
  const shopThemeRow = document.getElementById('shopThemeRow');  
  const limitedBadge = document.getElementById('limitedBadge');  
  
  // game sizes & state (kept)  
  let w,h,groundY;  
  let bird = {}, pipes = [], frameCount = 0, score = 0, speedMultiplier = 1;  
  let running = false, paused = false, muted = false;  
  const GRAVITY = 0.48, FLAP = -8.4, PIPE_GAP = 140, PIPE_WIDTH = 56, PIPE_SPACING = 180, PIPE_SPEED = 2.6, GROUND_HEIGHT = 90, BIRD_RADIUS = 14;  
  let highScore = parseInt(localStorage.getItem('tmi.flappy.high') || '0', 10);  
  highEl.textContent = highScore;  
  
  // theme config  
  function isXmasUnlocked(){ return true; } // unlocked for demo / immediate  
  const THEMES = [  
    {id:'normal', name:'Normal', bg:'#87CEEB', pipe:'#2E8B57', ground:'#DEB887', locked:false},  
    {id:'xmas', name:'Xmas', bg:'#6f1d1d', pipe:'#2b5f3a', ground:'#dfeaf0', locked:false, limited:true},  
    {id:'tmi', name:'TMI Purple', bg:'#1a0333', pipe:'#c6a0ff', ground:'#2b0b3a', locked:false, limited:true},  
    {id:'desert', name:'Desert', bg:'#f7e7d0', pipe:'#8b4513', ground:'#f4a460', locked:false},  
    {id:'winter', name:'Winter', bg:'#e6f4ff', pipe:'#9ED9FF', ground:'#ffffff', locked:true},  
    {id:'summer', name:'Summer', bg:'#ffd8a8', pipe:'#ff5400', ground:'#f4a460', locked:true},  
  ];  
  let selectedThemeId = localStorage.getItem('selectedTheme') || 'normal';  
  
  // visuals arrays  
  const clouds = [], snow = [], sparkles = [], reindeer = [];  
  
  // tree spawn control:  
  // ensure firstPipeIsTree true when starting; then treeCounter tracks pipes since last tree,  
  // spawn tree when treeCounter >= TREE_INTERVAL  
  let firstPipeTreePending = false;  
  let treeCounter = 0;  
  const TREE_INTERVAL = 6; // approx every 6 pipes after first  
  
  // canvas helpers  
  function fitCanvas(){  
    const rect = canvas.getBoundingClientRect();  
    const dpr = Math.max(1, window.devicePixelRatio || 1);  
    canvas.width = Math.floor(rect.width * dpr);  
    canvas.height = Math.floor(rect.height * dpr);  
    ctx.setTransform(dpr,0,0,dpr,0,0);  
  }  
  function initSizes(){  
    const rect = canvas.getBoundingClientRect();  
    w = rect.width;  
    h = rect.height;  
    groundY = h - GROUND_HEIGHT;  
  }  
  
  // seed visuals minimal  
  function seedVisuals(){  
    clouds.length = 0;  
    for(let i=0;i<6;i++) clouds.push({x:Math.random()*w, y:Math.random()*h*0.4, r:18+Math.random()*40, speed:0.2+Math.random()*0.4});  
    snow.length = 0;  
    for(let i=0;i<40;i++) snow.push({x:Math.random()*w, y:Math.random()*h, r:1+Math.random()*3, vy:0.3+Math.random()*1.2});  
    sparkles.length = 0;  
    reindeer.length = 0;  
    reindeer.push({x:w+40, y:h*0.25, speed:0.6 + Math.random()*0.8});  
  }  
  
  // apply theme visuals (kept)  
  function applyTheme(themeId){  
    const t = THEMES.find(x=>x.id===themeId) || THEMES[0];  
    document.documentElement.style.setProperty('--bg', t.bg);  
    document.documentElement.style.setProperty('--pipe', t.pipe);  
    document.documentElement.style.setProperty('--ground', t.ground);  
    if(t.limited && !t.locked){  
      limitedBadge.style.display = 'block';  
      limitedBadge.textContent = 'LIMITED';  
    } else limitedBadge.style.display = 'none';  
  }  
  
  // render theme tiles  
  function renderThemeTiles(){  
    themeRow.innerHTML = ''; shopThemeRow.innerHTML = '';  
    THEMES.forEach(t=>{  
      const tile = document.createElement('div');  
      tile.className = 'theme-tile' + (t.locked ? ' locked' : '');  
      tile.style.background = t.bg;  
      tile.dataset.id = t.id;  
      const label = document.createElement('div'); label.className = 'theme-label'; label.textContent = t.name;  
      tile.appendChild(label);  
      if(!t.locked){  
        tile.addEventListener('click', ()=>{  
          selectedThemeId = t.id;  
          localStorage.setItem('selectedTheme', selectedThemeId);  
          document.querySelectorAll('.theme-tile').forEach(n=>n.style.outline='none');  
          tile.style.outline = '3px solid rgba(0,0,0,0.12)';  
          if(t.limited){ limitedBadge.style.display='block'; limitedBadge.textContent='LIMITED'; } else limitedBadge.style.display='none';  
        });  
      } else {  
        const lock = document.createElement('div'); lock.textContent='ðŸ”’'; lock.style.fontSize='18px'; tile.appendChild(lock);  
      }  
      if(selectedThemeId === t.id && !t.locked){ tile.style.outline = '3px solid rgba(0,0,0,0.12)'; if(t.limited){ limitedBadge.style.display='block'; limitedBadge.textContent='LIMITED'; } }  
      themeRow.appendChild(tile);  
      const shopTile = tile.cloneNode(true);  
      shopThemeRow.appendChild(shopTile);  
    });  
  }  
  
  // spawnPipe now accepts forceTree boolean  
  function spawnPipe(x, forceTree=false){  
    const margin = 36;  
    const minGapTop = margin;  
    const maxGapTop = groundY - PIPE_GAP - margin;  
    const gapTop = Math.floor(Math.random() * (maxGapTop - minGapTop + 1) + minGapTop);  
  
    // decide if this pipe should be a tree:  
    let isTree = false;  
    // only spawn trees in Xmas theme  
    if(selectedThemeId === 'xmas'){  
      if(forceTree) {  
        isTree = true;  
        treeCounter = 0; // reset after forced tree  
      } else {  
        // after first forced tree, we count pipes; when count reaches TREE_INTERVAL, force a tree  
        if(treeCounter >= TREE_INTERVAL){  
          isTree = true;  
          treeCounter = 0;  
        } else {  
          treeCounter++;  
        }  
      }  
    }  
  
    pipes.push({ x, gapTop, passed:false, isTree: isTree, treeUsed:false });  
  }  
  
  // resetGame: ensure first pipe is a tree (Option C)  
  function resetGame(){  
    score = 0; speedMultiplier = 1; frameCount = 0; pipes = [];  
    bird = { x: Math.round(w*0.26), y: Math.round(h*0.5), vy:0, angle:0, resting:false, restStart:0 };  
    // force first pipe to be a tree if Xmas selected (option C)  
    firstPipeTreePending = (selectedThemeId === 'xmas');  
    treeCounter = 0;  
    if(firstPipeTreePending){  
      spawnPipe(w + 20, true); // first pipe is tree  
      // second pipe normal (no force)  
      spawnPipe(w + 20 + PIPE_SPACING, false);  
    } else {  
      spawnPipe(w + 20, false);  
      spawnPipe(w + 20 + PIPE_SPACING, false);  
    }  
    updateScore();  
    chaosEl.style.opacity = 0;  
  }  
  
  function updateScore(){  
    scoreEl.textContent = score;  
    highEl.textContent = Math.max(highScore, score);  
  }  
  
  // simple sparkle spawn  
  function spawnSparklesAt(x,y,count=8){  
    for(let i=0;i<count;i++){  
      sparkles.push({ x: x + (Math.random()*40-20), y: y + (Math.random()*40-20), r: 0.6+Math.random()*2, vx: (Math.random()-0.5)*2, vy: (Math.random()-1.5)*2, life: 500 + Math.random()*800, start: Date.now() });  
    }  
  }  
  
  // update logic (kept) with tree landing handling  
  function update(){  
    if(!running || paused) return;  
    frameCount++;  
  
    if(bird.resting){  
      const elapsed = (Date.now() - bird.restStart) / 1000;  
      if(elapsed >= 5){  
        bird.resting = false;  
        bird.vy = FLAP * 0.45;  
        spawnSparklesAt(bird.x, bird.y);  
      } else {  
        return; // still resting: pause physics  
      }  
    }  
  
    bird.vy += GRAVITY;  
    bird.y += bird.vy;  
    bird.angle = Math.max(-0.6, Math.min(1.2, bird.vy * 0.06));  
  
    const speed = PIPE_SPEED * speedMultiplier;  
  
    for(let i=pipes.length-1;i>=0;i--){  
      const p = pipes[i];  
      p.x -= speed;  
  
      if(!p.passed && p.x + PIPE_WIDTH/2 < bird.x){  
        p.passed = true;  
        score++;  
        flashScore();  
        updateScore();  
        if(score % 6 === 0) speedMultiplier += 0.08;  
      }  
      if(p.x + PIPE_WIDTH < -40) pipes.splice(i,1);  
    }  
  
    const rightMost = pipes.length ? Math.max(...pipes.map(p=>p.x)) : 0;  
    if(rightMost < w - PIPE_SPACING + 20){  
      // when spawning new pipe, ensure we don't accidentally force a tree unnecessarily.  
      // spawnPipe will manage treeCounter and occasional trees.  
      spawnPipe(w + 20, false);  
    }  
  
    // ground collision  
    if(bird.y + BIRD_RADIUS > groundY){  
      gameOver();  
      return;  
    }  
  
    // check collisions incl tree landing  
    for(const p of pipes){  
      const px = p.x, py = p.gapTop, gap = PIPE_GAP;  
      if(bird.x + BIRD_RADIUS > px && bird.x - BIRD_RADIUS < px + PIPE_WIDTH){  
        // handle tree landing if tree exists and unused  
        if(p.isTree && !p.treeUsed && selectedThemeId === 'xmas'){  
          // define landing zone: a horizontal band around the top of the gap + small tolerance  
          const landingYTop = py + gap - 48; // area above branch platform  
          const landingYBottom = py + gap + 40; // area below branch top  
          if(bird.y + BIRD_RADIUS > landingYTop && bird.y + BIRD_RADIUS < landingYBottom){  
            p.treeUsed = true;  
            bird.resting = true;  
            bird.restStart = Date.now();  
            bird.vy = 0;  
            spawnSparklesAt(bird.x, bird.y);  
            return;  
          }  
        }  
        // normal collision with pipe bodies  
        if(bird.y - BIRD_RADIUS < py || bird.y + BIRD_RADIUS > py + gap){  
          gameOver();  
          return;  
        }  
      }  
    }  
  }  
  
  // gameOver (kept)  
  function gameOver(){  
    running = false;  
    showChaos();  
    spawnShake(8, 400);  
    if(score > highScore){  
      highScore = score;  
      localStorage.setItem('tmi.flappy.high', highScore);  
    }  
    highEl.textContent = highScore;  
    overlay.style.display = 'flex';  
    messageEl.textContent = 'Game Over! Browse avatars or restart.';  
  }  
  
  function flap(){  
    if(!running) return;  
    if(bird.resting) return;  
    bird.vy = FLAP;  
    spawnSparklesAt(bird.x - 8, bird.y);  
  }  
  
  // minimal particle / sparkles arrays & functions  
  function spawnShake(amount, ms){ window._shakeAmount = amount; window._shakeUntil = Date.now() + ms; }  
  function flashScore(){ spawnSparklesAt(60, 40, 10); }  
  
  // drawing helpers  
  function drawBackground(){  
    const t = THEMES.find(x=>x.id===selectedThemeId) || THEMES[0];  
    const g = ctx.createLinearGradient(0,0,0,h);  
    g.addColorStop(0, t.bg);  
    g.addColorStop(0.6, lightenHex(t.bg, 0.18));  
    g.addColorStop(1, '#e8f6ff');  
    ctx.fillStyle = g;  
    ctx.fillRect(0,0,w,h);  
  
    // clouds  
    clouds.forEach(c => {  
      c.x -= c.speed * 0.6;  
      if(c.x + c.r*4 < -50) c.x = w + 60;  
      ctx.globalAlpha = 0.85;  
      drawCloud(c.x, c.y, c.r);  
      ctx.globalAlpha = 1;  
    });  
  
    // snow or other theme visuals  
    if(selectedThemeId === 'xmas' || selectedThemeId === 'winter'){  
      snow.forEach(s => { s.y += s.vy; if(s.y > h) { s.y = -10; s.x = Math.random()*w; } drawSnowDot(s.x, s.y, s.r); });  
    }  
  }  
  
  function drawCloud(x,y,r){  
    ctx.save();  
    ctx.fillStyle = 'rgba(255,255,255,0.92)';  
    ctx.beginPath(); ctx.ellipse(x,y,r*1.6, r*1.0, 0, 0, Math.PI*2); ctx.fill();  
    ctx.beginPath(); ctx.ellipse(x + r*0.6, y - r*0.4, r*1.1, r*0.8, 0, 0, Math.PI*2); ctx.fill();  
    ctx.restore();  
  }  
  function drawSnowDot(x,y,r){ ctx.save(); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.restore(); }  
  
  // draw pipes and tree (tree drawn when p.isTree true)  
  function drawPipes(){  
    for(const p of pipes){  
      const px = p.x;  
      const top = p.gapTop;  
      const bottomTop = p.gapTop + PIPE_GAP;  
      const t = THEMES.find(x=>x.id===selectedThemeId) || THEMES[0];  
      const pipeColor = t.pipe;  
  
      ctx.save();  
      // black outline shadow  
      ctx.fillStyle = '#000';  
      ctx.fillRect(px - 4, 0, PIPE_WIDTH + 8, top + 6);  
      // top pipe gradient  
      const gradTop = ctx.createLinearGradient(px, 0, px + PIPE_WIDTH, 0);  
      gradTop.addColorStop(0, shadeColor(pipeColor, -12));  
      gradTop.addColorStop(0.5, pipeColor);  
      gradTop.addColorStop(1, shadeColor(pipeColor, 18));  
      ctx.fillStyle = gradTop;  
      ctx.fillRect(px, 0, PIPE_WIDTH, top);  
      ctx.fillStyle = 'rgba(255,255,255,0.06)';  
      ctx.fillRect(px, Math.max(0, top - 8), PIPE_WIDTH, 8);  
  
      // bottom pipe  
      ctx.fillStyle = '#000';  
      ctx.fillRect(px - 4, bottomTop - 6, PIPE_WIDTH + 8, groundY - (bottomTop - 6));  
      const gradBottom = ctx.createLinearGradient(px, bottomTop, px + PIPE_WIDTH, bottomTop + 200);  
      gradBottom.addColorStop(0, shadeColor(pipeColor, 8));  
      gradBottom.addColorStop(1, shadeColor(pipeColor, -8));  
      ctx.fillStyle = gradBottom;  
      ctx.fillRect(px, bottomTop, PIPE_WIDTH, groundY - bottomTop);  
      ctx.fillStyle = 'rgba(255,255,255,0.06)';  
      ctx.fillRect(px, bottomTop, PIPE_WIDTH, 6);  
  
      // Decorations and tree  
      if(p.isTree && selectedThemeId === 'xmas'){  
        drawXmasTree(px + PIPE_WIDTH/2, bottomTop - 20); // tree sits where bottom pipe would be  
      } else {  
        if(selectedThemeId === 'xmas') drawStringLights(px, top, bottomTop);  
        if(selectedThemeId === 'winter') drawIcicles(px, top, bottomTop);  
        if(selectedThemeId === 'tmi') drawQuicksilverEdge(px, top, bottomTop);  
        if(selectedThemeId === 'summer') drawSunWrap(px, top, bottomTop);  
      }  
  
      ctx.restore();  
    }  
  }  
  
  // minimal Xmas tree (cartoony) drawn at (cx, baseY)  
  function drawXmasTree(cx, baseY){  
    ctx.save();  
    // tree layers: 3 triangles  
    const layers = 3;  
    const colors = ['#0b6b2f','#0e7f36','#149941'];  
    let hLayer = 36;  
    for(let i=0;i<layers;i++){  
      ctx.fillStyle = colors[i%colors.length];  
      const wLayer = 120 - i*22;  
      const y = baseY - (layers - i) * (hLayer - 4);  
      ctx.beginPath();  
      ctx.moveTo(cx - wLayer/2, y + hLayer);  
      ctx.lineTo(cx + wLayer/2, y + hLayer);  
      ctx.lineTo(cx, y);  
      ctx.closePath();  
      ctx.fill();  
      // lights on layer  
      for(let l=0; l<5; l++){  
        ctx.fillStyle = ['#ffd700','#ff4444','#00eaff','#ff7bff'][l%4];  
        const lx = cx - wLayer/2 + (l+1)*(wLayer/6) + (Math.random()*6-3);  
        const ly = y + hLayer - (Math.random()*14);  
        ctx.beginPath(); ctx.arc(lx, ly, 3, 0, Math.PI*2); ctx.fill();  
      }  
    }  
    // trunk  
    ctx.fillStyle = '#6b3f24';  
    ctx.fillRect(cx - 10, baseY + 44, 20, 28);  
    // star  
    ctx.fillStyle = '#ffd54f';  
    ctx.beginPath(); ctx.arc(cx, baseY - 14, 7, 0, Math.PI*2); ctx.fill();  
    // subtle outline  
    ctx.strokeStyle = '#000';  
    ctx.lineWidth = 1;  
    ctx.strokeRect(cx - 60, baseY - 80, 120, 120); // small bbox for debugging (can remove)  
    ctx.restore();  
  }  
  
  // string lights, icicles, quicksilver etc (kept simple)  
  function drawStringLights(px, top, bottomTop){  
    ctx.save();  
    const colors = ['#ffeb3b','#ff5252','#00e676','#00b0ff','#ff80ab'];  
    const step = 14;  
    for(let y = top + 12; y < bottomTop - 12; y += step){  
      const x1 = px + 4;  
      const x2 = px + PIPE_WIDTH - 4;  
      const mix = (Math.sin(y*0.1 + frameCount*0.06) + 1) / 2;  
      const cxPos = x1 + (x2 - x1) * mix;  
      ctx.beginPath();  
      ctx.strokeStyle = 'rgba(200,200,200,0.28)';  
      ctx.moveTo(x1, y);  
      ctx.quadraticCurveTo(px + PIPE_WIDTH/2, y + 6, x2, y);  
      ctx.stroke();  
      ctx.fillStyle = colors[(y/step|0)%colors.length];  
      ctx.beginPath(); ctx.arc(cxPos, y, 3, 0, Math.PI*2); ctx.fill();  
    }  
    ctx.restore();  
  }  
  function drawIcicles(px, top, bottomTop){  
    ctx.save();  
    ctx.fillStyle = '#dff3ff';  
    for(let i=0;i<6;i++){  
      const ix = px + i * (PIPE_WIDTH / 6) + 6;  
      const ih = 6 + Math.random()*12;  
      ctx.beginPath();  
      ctx.moveTo(ix, top - 2);  
      ctx.lineTo(ix + 6, top - 2);  
      ctx.lineTo(ix + 3, top - 2 + ih);  
      ctx.closePath();  
      ctx.fill();  
    }  
    ctx.restore();  
  }  
  function drawQuicksilverEdge(px, top, bottomTop){  
    ctx.save();  
    ctx.strokeStyle = 'rgba(180,100,255,0.9)';  
    ctx.lineWidth = 2;  
    ctx.strokeRect(px - 2, top, PIPE_WIDTH + 4, bottomTop - top);  
    ctx.restore();  
  }  
  function drawSunWrap(px, top, bottomTop){  
    ctx.save();  
    const grad = ctx.createRadialGradient(px + PIPE_WIDTH/2, top + (bottomTop-top)/2, 0, px + PIPE_WIDTH/2, top + (bottomTop-top)/2, 80);  
    grad.addColorStop(0, 'rgba(255,220,120,0.12)');  
    grad.addColorStop(1, 'rgba(255,120,60,0)');  
    ctx.fillStyle = grad;  
    ctx.fillRect(px - 30, top - 30, PIPE_WIDTH + 60, bottomTop - top + 60);  
    ctx.restore();  
  }  
  
  function drawGround(){  
    const t = THEMES.find(x=>x.id===selectedThemeId) || THEMES[0];  
    ctx.fillStyle = t.ground;  
    ctx.fillRect(0, groundY, w, h - groundY);  
    ctx.fillStyle = 'rgba(0,0,0,0.06)';  
    ctx.fillRect(0, groundY, w, 4);  
  }  
  
  // bird drawing (kept simple)  
  function drawBird(){  
    ctx.save();  
    const ox = (window._shakeAmount && Date.now() < (window._shakeUntil||0)) ? (Math.random()*window._shakeAmount - window._shakeAmount/2) : 0;  
    const oy = (window._shakeAmount && Date.now() < (window._shakeUntil||0)) ? (Math.random()*window._shakeAmount - window._shakeAmount/2) : 0;  
    if(Date.now() > (window._shakeUntil||0)) window._shakeAmount = 0;  
    ctx.translate(ox, oy);  
  
    ctx.translate(bird.x, bird.y);  
    ctx.rotate(bird.angle);  
  
    ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(0,0,BIRD_RADIUS+2,0,Math.PI*2); ctx.fill();  
    ctx.beginPath(); ctx.fillStyle = '#ffdd44'; ctx.arc(0,0,BIRD_RADIUS,0,Math.PI*2); ctx.fill();  
    ctx.beginPath(); ctx.fillStyle = '#111'; ctx.arc(6,-4,3,0,Math.PI*2); ctx.fill();  
    ctx.beginPath(); ctx.fillStyle = '#F4B400'; ctx.ellipse(-2,6,8,5,-0.5,0,Math.PI*2); ctx.fill();  
  
    if(selectedThemeId === 'xmas'){  
      ctx.save();  
      ctx.translate(-4, -18);  
      ctx.fillStyle = '#c62828';  
      ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(0,-12); ctx.lineTo(16,2); ctx.closePath(); ctx.fill();  
      ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(10,2,3,0,Math.PI*2); ctx.fill();  
      ctx.restore();  
    } else if(selectedThemeId === 'summer'){  
      ctx.save(); ctx.fillStyle = '#111'; ctx.fillRect(1,-10,10,6); ctx.fillRect(-3,-10,6,6); ctx.fillStyle = '#333'; ctx.fillRect(5,-10,2,6); ctx.restore();  
    } else if(selectedThemeId === 'tmi'){  
      ctx.save(); ctx.fillStyle = '#c6a0ff'; ctx.beginPath(); ctx.arc(-14,-6,4,0,Math.PI*2); ctx.fill(); ctx.restore();  
    } else if(selectedThemeId === 'winter'){  
      ctx.save(); ctx.strokeStyle = '#e6f7ff'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.arc(0,0,BIRD_RADIUS-2,0,Math.PI*2); ctx.stroke(); ctx.restore();  
    }  
  
    ctx.restore();  
  }  
  
  function drawSparkles(){  
    const now = Date.now();  
    for(let i=sparkles.length-1;i>=0;i--){  
      const p = sparkles[i];  
      const age = now - (p.start || now);  
      const life = p.life || 800;  
      const t = 1 - age / life;  
      if(t <= 0){ sparkles.splice(i,1); continue; }  
      ctx.globalAlpha = t;  
      ctx.fillStyle = '#fff';  
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r * t * 1.6, 0, Math.PI*2); ctx.fill();  
      p.x += (p.vx || 0) * 0.8; p.y += (p.vy || 0) * 0.8;  
      ctx.globalAlpha = 1;  
    }  
  }  
  
  function draw(){  
    drawBackground();  
    drawPipes();  
    drawGround();  
    drawSparkles();  
    drawBird();  
    requestAnimationFrame(draw);  
  }  
  
  // small helpers  
  function lightenHex(hex, amt){ const c = hex.replace('#',''); const num = parseInt(c,16); let r = (num >> 16) + Math.round(255*amt); let g = (num >> 8 & 0x00FF) + Math.round(255*amt); let b = (num & 0x0000FF) + Math.round(255*amt); r = Math.min(255, Math.max(0, r)); g = Math.min(255, Math.max(0, g)); b = Math.min(255, Math.max(0, b)); return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1); }  
  function shadeColor(hex, percent){ const f = parseInt(hex.slice(1),16), t = percent<0?0:255, p = Math.abs(percent)/100; const R = Math.round((t - (f>>16)) * p) + (f>>16); const G = Math.round((t - (f>>8 & 0x00FF)) * p) + (f>>8 & 0x00FF); const B = Math.round((t - (f & 0x0000FF)) * p) + (f & 0x0000FF); return "#" + (0x1000000 + (R<<16) + (G<<8) + B).toString(16).slice(1); }  
  
  // chaos UI  
  function showChaos(){  
    const lines = ["Ramaphosa's economy just cried. You lost it. ðŸ« ","Chaos: 1 â€” your dignity: 0. ðŸ’€","Broâ€¦ that was aesthetic failure. Much shame. ðŸ˜¬","You got folded like laundry. TMI. ðŸ”¥","Your ancestors are buffering after that one. ðŸ“¶","That jump was sponsored by Eskom. No power. âš¡","You flapped like NSFAS payments â€” delayed. ðŸ’¸","Even your WiFi is judging that move. ðŸ“¡","That flap was weaker than Monday motivation. ðŸ˜´","You just invented a new way to lose gracefully. ðŸ‘","Not even Ronaldo would hit that jump. âš½"];  
    chaosEl.textContent = lines[Math.floor(Math.random()*lines.length)];  
    chaosEl.style.opacity = 1;  
    setTimeout(()=> chaosEl.style.opacity = 0, 2600);  
  }  
  
  // events  
  startBtn.addEventListener('click', (e)=>{ e.preventDefault(); startGame(); });  
  shopBtn.addEventListener('click', (e)=>{ e.preventDefault(); shopOverlay.style.display = 'flex'; renderThemeTiles(); });  
  shopBackBtn.addEventListener('click', (e)=>{ e.preventDefault(); shopOverlay.style.display = 'none'; });  
  muteBtn.addEventListener('click', (e)=>{ e.preventDefault(); muted = !muted; muteBtn.textContent = muted ? 'Unmute' : 'Mute'; });  
  
  frame.addEventListener('pointerdown', (e)=>{ if(overlay.style.display !== 'none' || shopOverlay.style.display === 'flex') return; flap(); });  
  window.addEventListener('keydown', (e)=>{ if(e.code === 'Space') flap(); });  
  
  function startGame(){  
    applyTheme(selectedThemeId);  
    messageEl.textContent = "Tap to start. Avoid the pipes. Build high score.";  
    overlay.style.display = 'none';  
    shopOverlay.style.display = 'none';  
    resetGame();  
    running = true;  
    paused = false;  
  }  
  
  // main loops  
  function loop(){ update(); setTimeout(loop, 1000/60); }  
  
  // init  
  window.addEventListener('resize', ()=>{ fitCanvas(); initSizes(); seedVisuals(); });  
  function seedVisuals(){ clouds.length=0; snow.length=0; sparkles.length=0; reindeer.length=0; for(let i=0;i<6;i++) clouds.push({x:Math.random()*w,y:Math.random()*h*0.4,r:18+Math.random()*40,speed:0.2+Math.random()*0.4}); for(let i=0;i<40;i++) snow.push({x:Math.random()*w,y:Math.random()*h,r:1+Math.random()*3,vy:0.3+Math.random()*1.2}); reindeer.push({x:w+40,y:h*0.25,speed:0.6+Math.random()*0.8}); }  
  fitCanvas(); initSizes(); seedVisuals(); renderThemeTiles(); applyTheme(selectedThemeId); draw(); loop();  
  
  // expose debug  
  window.TMIFlappyDebug = { spawnPipe, pipes, bird, resetGame, applyTheme, THEMES, sparkles };  
})();  
</script>  </body>  
</html>